<#@   assembly name="$(SolutionDir)\bin\Debug\Alba.Framework.dll"
#><#@ import namespace="System.Collections.Generic"
#><#@ import namespace="Alba.Framework.Text"
#><#@ import namespace="Alba.Framework.Collections"
#><#@ include file="$(SolutionDir)\Alba.Framework\Alba.Framework.CodeGeneration\T4\Common.ttinclude"
#><#+
    string sArg = @"(?:[^,()]|(?<b>\()|(?<-b>\)))+(?(b)(?!))";
    string sArgs = @"(?:[^()]|(?<b>\()|(?<-b>\)))+(?(b)(?!))";
    string sBlock = @"(?:[^{}]|(?<b>{)|(?<-b>}))+(?(b)(?!))";
    string[] CommonDefs = { "MOZ_FLEXBOX" };
    ISet<string> CSharpKeywords = new[] {
        "abstract", "as", "base", "bool", "break", "byte", "case", "catch", "char", "checked", "class", "const",
        "continue", "decimal", "default", "delegate", "do", "double", "else", "enum", "event", "explicit", "extern", "false",
        "finally", "fixed", "float", "for", "foreach", "goto", "if", "implicit", "in", "int", "interface",
        "internal", "is", "lock", "long", "namespace", "new", "null", "object", "operator", "out", "override",
        "params", "private", "protected", "public", "readonly", "ref", "return", "sbyte", "sealed", "short", "sizeof", "stackalloc",
        "static", "string", "struct", "switch", "this", "throw", "true", "try", "typeof", "uint", "ulong", "unchecked",
        "unsafe", "ushort", "using", "virtual", "void", "volatile", "while",
    }.ToSet();
    IDictionary<string, string> TypeRenames = new SortedList<string, string> {
        { "nsCSSProperty", "CssProperty" },
        { "nsCSSPseudoClass", "CssPseudoClass" },
        { "nsCSSPseudoElement", "CssPseudoElement" },
        { "nsCSSUnit", "CssUnit" },
        { "nsAttrFunc", "CssAttrFunction" },
        { "nsMediaFeature", "CssMediaFeature" },
        { "nsMediaExpression", "CssMediaExpression" },
        { "nsMediaQuery", "CssMediaQuery" },
        { "URLValue", "CssUriValue" },
        { "nsCSSRect", "CssRect" },
        { "nsCSSValueGradientStop", "CssValueGradientStop" },
        { "nsCSSValueGradient", "CssValueGradient" },
        { "nsCSSValueTriplet", "CssValueTriplet" },
        { "nsCSSValuePair", "CssValuePair" },
        { "nsCSSValueList", "CssValueList" },
        { "nsCSSValuePairList", "CssValuePairList" },
        { "nsCSSValue", "CssValue" },
        { "Rule", "CssRule" },
        { "CharsetRule", "CssCharsetRule" },
        { "CSSSupportsRule", "CssSupportsRule" },
        { "DocumentRule", "CssDocumentRule" },
        { "GroupRule", "CssGroupRule" },
        { "ImportRule", "CssImportRule" },
        { "MediaRule", "CssMediaRule" },
        { "NameSpaceRule", "CssNamespaceRule" },
        { "nsCSSFontFaceRule", "CssFontFaceRule" },
        { "nsCSSKeyframeRule", "CssKeyframeRule" },
        { "nsCSSKeyframesRule", "CssKeyframesRule" },
        { "nsCSSPageRule", "CssPageRule" },
        { "StyleRule", "CssStyleRule" },
        { "nsCSSSelector", "CssSelector" },
        { "nsCSSSelectorList", "CssSelectorGroup" },
        { "nsCSSStyleSheet", "CssStyleSheet" },
        { "nsCSSFontFaceStyleDecl", "CssFontFace" },
        { "nsAttrSelector", "CssAttrSelector" },
        { "nsPseudoClassList", "CssPseudoClassSelector" },
        { "nsCSSParser", "CssParser" },
        { "Declaration", "CssDeclaration" },
        { "RuleKind", "CssRuleKind" },
        { "nscolor", "CssColor" },
    };

    string ToId (string name)
    {
        return CSharpKeywords.Contains(name) ? "@" + name : name;
    }

    string ToPascalId (string name)
    {
        var sb = new StringBuilder(name.Length);
        bool isNextUpper = true;
        foreach (var c in name) {
            if (c == '_') {
                isNextUpper = true;
            }
            else {
                sb.Append(isNextUpper ? char.ToUpper(c) : char.ToLower(c));
                isNextUpper = false;
            }
        }
        return ToId(sb.ToString());
    }

    string ToPascalId (Match m)
    {
        return ToPascalId(m.Get());
    }

    void WriteTypeRenames ()
    {
        foreach (var rename in TypeRenames) {
#>
    using <#=rename.Key#> = <#=rename.Value#>;
<#+     }
    }

    string Refactor (string source)
    {
        return source
            .ReReplace(@"(?x)\b(?<Type>
                            RuleKind
                        )\b", m => TypeRenames[m.Get("Type")])
            ;
    }
#>